# my-mini-vue

# 学习记录

## 响应式需求的根源
- v1
一开始我们使用一个变量b去依赖一个变量a的时候，每当a发生了变化，b想变化的时候，我们需要给她进行一次硬性赋值，每次都要去写相同的赋值代码，重复性很高，
- v2
这里我们尝试将依赖变化后所需要执行的同步代码进行分装后变成一个update函数，虽然有一定的分装性，同时每次更新只需要调用方法，但是依旧是我们在手动操作，
- v3
如何让它能够变成自动执行，就是响应式的核心：让同步更新变成自动的

## 响应式数据与依赖收集

在vue3中，声明响应式数据与依赖收集已经被单独抽离到了`@vue/reactivity` 这个包中
可以引入包中的`effect`进行依赖搜集；`reactive`声明响应式数据，这样在reactive过后的数据改变时就会触发对应的收集到的依赖
这里我们就要尝试来实现这两个方法

具体的实现思路
[完整代码](./core/reactivity/index.js)

首先是需要一个收集的函数（这里叫effectWatch）
同时需要一个储存并执行依赖的地方，因为具备通用性，所以这里采用一个class Dep来做

注意：
收集依赖时，其实不需要重复依赖，所以储存依赖的地方`effects`采用es6+的set来做，同时提供一个depend方法进行搜集依赖；一个notice遍历并执行已经收集过的依赖；
并且当我们获取实例或者给实例赋值时都会被动的触发在class中定义的get与set，**这两个属性是做出响应式的关键**

这里出现的第一个问题是怎么让new Dep 的实例能与依赖收集方法收集到的内容建立起关联呢？

方法1是将新生成的实例传给effectWatch方法并把effectWatch收集到的依赖方法通过调用实例的depend将依赖添加到对应的实例依赖列表里（缺点：每次都要传入对应的实例，而且`@vue/reactivity`中提供的effect也不需要传入对应的实例）

那么方法1不行，采用方法2，可以定义一个全局变量currentEffect，在每次调用effectWatch的时候就将依赖赋值给中间变量，同时调用一次方法，那么方法中去获取实力对应的属性时就会去触发get操作，在这个时候我们就可以在get中调用depend。然后在将currentEffect清空。

那么在上面实现完了get基本上就完成了，但是我们需要测试模拟一下effectWatch的效果，所以在定义好set并且在赋值完成后调用notice。这样一个对单值变更的响应式依赖收集方法就完成了，做到这里其实已经实现了一个类似`ref`的功能了
